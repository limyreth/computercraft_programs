-- Mine layers [6, 15] (<6 has bedrock)
-- Makes a shaft down from its starting location
-- Mines first quadrant, second, third, fourth
-- Returns when full, drops stuff in chest in front, refuses to leave unless everything dropped
-- Returns when fuel becomes low, expects chest with fuel to its left
-- Returning implies using gps to go to (x, z) spot, points back to its original orientation, moves up to starting y
-- Starting location is passed as program args and is referred to as Home location
-- Startup script calls this thing!
-- Skip cobble, dirt

-- ENSURE: At any point in time, program must be able to handle being aborted and restarted

local STATE_FILE = "/state"

Miner = {}
Miner.__index = Miner

function Miner:new()
	obj = {}
	setmetatable(obj, self)
	return obj
end

-- Load from file
function Miner::load()
	-- load persistent things
	if fs.exists(STATE_FILE) then
		-- home_pos, state, destination
	else
		self.home_pos = gps.locate()
		self.state = "initial"
		self.destination = nil
	end
	
	-- init transient vars
	self.pos = gps.locate()
end

-- Save state to file
function Miner::save()
	error("Not implemented")
end

-- assumes 0 points along the x-axis towards the increasing part.
-- values: 0..3
-- 1 points to positive z-axis
local orientation = 0

local mining_layer = 6
local mining_column = home_pos.z
local mining_orientation = 0  -- or 2

-- transient things below
local drop_slots = {15, 16}  -- recommend cobble and dirt

local inventory_slots = {}
for i=1,16 do
	inventory_slots[i] = i
end
for slot in drop_slots do
	table.remove(inventory_slots, slot)
end

function orientate(orient)
	while orientation ~= orient do
		turnRight()
	end
end

function up()
	if not turtle.up() then
		error("Failed to move up")
	end
end

function down()
	if turtle.detectDown() then
		if not turtle.digDown() then
			error("Failed to dig down")
		end
	end
	
	if not turtle.down() then
		error("Failed to move down")
	end
end

function forward()
	if not turtle.forward() then
		error("Failed to move forward")
	end
	if orientation == 0 then
		pos.x = pos.x + 1
	elseif orientation == 1 then
		pos.z = pos.z + 1
	elseif orientation == 2 then
		pos.x = pos.z - 1
	elseif orientation == 3 then
		pos.z = pos.z - 1
	end
end

-- Assumes that destination can be reached by first moving along x, then z, then y
function move()
	pos = gps.get()
	if pos.x ~= destination.x then
		if destination.x > pos.x then
			orientate(0)
		else
			orientate(2)
		end
		forward()
	elseif pos.z ~= destination.z then
		if destination.z > pos.z then
			orientate(1)
		else
			orientate(3)
		end
		forward()
	elseif pos.y ~= destination.y then
		if destination.y > pos.y then
			up()
		else
			down()
		end
	else
		destination = nil
	end
end

function hasReachedDestination()
	return destination == nil
end

function throw(str)
	error({message=str})
end

function turnLeft()
	if not turtle.turnLeft() then
		error("Failed to turn left")
	end
	orientation = (orientation - 1) % 4
end

function turnRight()
	if not turtle.turnRight() then
		error("Failed to turn right")
	end
	orientation = (orientation + 1) % 4
end

function goHome()
	state = "going home"
	destination = home_pos
end

-- returns false if turtle can no longer dig
function dig()
	if not turtle.detect() then
		return true
	end
	
	if not turtle.dig() then
		return false
	end
	
	-- drop useless things if we grabbed some of it
	for slot in dropSlots do
		local count = turtle.getItemCount(slot)
		if count > 1 then
			turtle.select(slot)
			if not turtle.dropDown(count - 1) then
				error("Failed to drop some of: " .. slot)
			end
		end
	end
	
	return true
end

function goMine()
	state = "mining"
	destination = home_pos -- TODO is debug
	destination.y = 6
end

function mine()
	return turnLeft() and
		dig() and
		turnRight() and
		turnRight() and
		dig() and
		turnLeft() and
		dig()
end

function isLowOnFuel()
	local needed_fuel = (math.abs(destination.x - pos.x) +
							math.abs(destination.y - pos.y) +
							math.abs(destination.z - pos.z) +
							10)  -- margin of 10
	return needed_fuel <= turtle.getFuelLevel()
end

function tick()
	move()
	
	-- TODO distance check
	
	if hasReachedDestination() then
		if state == "going home" then
			-- TODO drop stuff in chest
			read()
			goMine()
		elseif state == "going to mine" then
			error("Have yet to implement")
		elseif state == "mining" then
			-- TODO what if inventory full, ...
			if mine() then
				--TODO destination = ... next
			else
				goHome()
			end
		elseif state == "error" then
			exit()
		else
			throw("Invalid state: " .. state)
		end
	end
	
	if isLowOnFuel() then
		goHome()
	end
end

read()
while true do
	local status, e = pcall(tick())
	if not status then
		state = "error"
		destination = home_pos
		
		print(e.message) -- TODO save to file
		-- TODO rednet, perhaps, maybe
	end
	os.sleep(0.1)  -- avoid infinite loop, rm when it's safe
end
